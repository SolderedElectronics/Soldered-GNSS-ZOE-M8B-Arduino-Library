<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GNSS ZOE M8B Arduino Library: How I&lt;sup&gt;2&lt;/sup&gt;C (aka DDC) communication works with a u-blox module</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="custom.css" rel="stylesheet" type="text/css"/>
<link href="custom_dark_theme.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">GNSS ZOE M8B Arduino Library<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">This is a library for the SGNSS ZOE M8B Module</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_src__spark_fun_u_blox__g_n_s_s__arduino__library_main__theory.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">How I<sup>2</sup>C (aka DDC) communication works with a u-blox module </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p >When the user calls one of the methods the library will poll the u-blox module for new data.</p>
<ul>
<li>Wait for a minimum of 25 ms between polls (configured dynamically when update rate is set)</li>
<li>Write 0xFD to module</li>
<li>Read two bytes (0xFD and 0xFE) for bytes available</li>
<li>Otherwise, read number of bytes and process into NMEA, UBX, or RTCM frame.</li>
<li>If checksum is valid, flag frame as complete.</li>
</ul>
<p >This library was originally written to use the I<sup>2</sup>C interface but Serial has been implemented as well.</p>
<h1><a class="anchor" id="autotoc_md55"></a>
How data is processed by this library</h1>
<p >In Version 1 of this library, we tried to minimize memory usage by being very careful about how much RAM we allocated to UBX packet storage and processing. We used only three buffers or containers to store the incoming data: <b>packetBuf</b> (packetBuffer); <b>packetCfg</b> (packetConfiguration); and <b>packetAck</b> (packetAcknowledge). Incoming packets were stored in <b>packetBuf</b> initially and then diverted into <b>packetAck</b> or <b>packetCfg</b> as necessary. Once data was received and validated, it would be copied out of <b>packetCfg</b> and into 'global' variables with names like <code>gpsSecond</code> or <code>latitude</code>. We also introduced the concept of <em>Polling vs. Auto-Reporting</em> where messages like PVT (Position, Velocity, Time) could be generated and parsed "automatically". This meant that functions like <code>getLatitude</code> could be non-blocking, returning the most recent data and requesting fresh data when necessary. But it also meant that <em>polled</em> messages could be <em>overwritten</em> (in <b>packetCfg</b>) by any <em>auto-reported</em> messages. The library dealt with this successfully, but it was a headache.</p>
<p >Version 1 had two main drawbacks. As time went on:</p><ul>
<li>the RAM use increased as we had to add new 'global' storage for each new data type</li>
<li>the number of messages which needed "auto" processing through <b>packetCfg</b> became complex, requiring significant code changes each time a new "auto" message was added. (We started with NAV-PVT. Then came NAV-HPPOSLLH and NAV-DOP. Things got complicated when HNR-ATT, HNR-INS and HNR-PVT were added to the mix.)</li>
</ul>
<p >Version 2 of the library does things differently. Whilst of course trying to keep the library backward-compatible as much as possible, we have taken a fresh approach:</p><ul>
<li>We have added <b>packetAuto</b> which is used to temporarily buffer expected auto-reported messages and prevents data from being overwritten in <b>packetCfg</b>.<ul>
<li>The payload for <b>packetAuto</b> is allocated dynamically in RAM and deleted after use.</li>
<li>If insufficient RAM is available, the code falls back to using <b>packetCfg</b> to buffer the data instead.</li>
</ul>
</li>
<li>The library no longer uses 'global' (permanently-allocated) storage for the GNSS data. Instead:<ul>
<li>Each message type has a <b>typedef struct</b> defined which matches the format of the UBX message. (<em>typedef structs</em> are just definitions, they don't occupy memory.) You can find the definitions in <a href="./src/u-blox_structs.h"><em><b>u-blox_structs.h</b></em></a>.</li>
<li>The struct allows each data field (latitude, longitude, etc.) to be read simply and easily using dot notation. Flags etc. are supported by bit definitions in the struct. The field names are as defined in the u-blox interface description.</li>
<li>Storage for that message is only <em>allocated</em> in RAM if/when required. The allocation is done using <em>new</em> via a pointer to the struct.</li>
</ul>
</li>
<li><em>Any</em> message can be "auto" if required, but can be polled too.</li>
<li>An optional <em>callback</em> can be associated with the arrival of each message type. A simple scheduler <code>checkCallbacks</code> triggers the callbacks once I<sup>2</sup>C/Serial data reception is complete.<ul>
<li>This means that your code no longer needs to wait for the arrival of a message, you are able to request (e.g.) PVT or HNR data and your callback is called once the data arrives.</li>
<li>The callbacks are not re-entrant.</li>
<li>The callback receives a <em>copy</em> of the data, so data reception and processing can continue while the callback is executing. Data integrity is preserved. You can call <code>checkUblox()</code> from inside a callback if needed.</li>
</ul>
</li>
<li>Incoming data can be copied to a separate buffer to allow automatic writing to a file on SD card, which will be useful for (e.g.) RAWX logging.<ul>
<li>Data is stored in a RingBuffer, the size of which can be set by calling <code>setFileBufferSize</code> <em>before</em> <code>.begin</code>.</li>
<li>The default buffer size is zero - to save memory.</li>
<li>To simplify SD card writing, data can be copied from the RingBuffer to a user-defined linear buffer first using <code>extractFileBufferData</code>.</li>
<li>Data reception and processing can continue during the SD write.</li>
<li>User-defined code does the actual writing of data from the linear buffer to the SD card. The u-blox GNSS library itself does not perform the writing and so is not tied to any particular SD library.</li>
<li>The logged files can be played back and analyzed with (e.g.) u-center or RTKLIB.</li>
</ul>
</li>
</ul>
<p >In terms of RAM, you may find that your total RAM use is lower using v2 compared to v1, but it does of course depend on how many message types are being processed. The downside to this is that it is difficult to know in advance how much RAM is required, since it is only allocated if/when required. If the processor runs out of RAM (i.e. the <em>new</em> fails) then a debug error message is generated.</p>
<h1><a class="anchor" id="autotoc_md56"></a>
"Auto" messages</h1>
<p >In v2.0, the full list of messages which can be processed and logged automatically is:</p><ul>
<li>UBX-NAV-POSECEF (0x01 0x01): Position solution in ECEF</li>
<li>UBX-NAV-STATUS (0x01 0x03): Receiver navigation status</li>
<li>UBX-NAV-DOP (0x01 0x04): Dilution of precision</li>
<li>UBX-NAV-ATT (0x01 0x05): Attitude solution (<b>only with ADR or UDR products</b>)</li>
<li>UBX-NAV-PVT (0x01 0x07): Navigation position velocity time solution</li>
<li>UBX-NAV-ODO (0x01 0x09): Odometer solution</li>
<li>UBX-NAV-VELECEF (0x01 0x11): Velocity solution in ECEF</li>
<li>UBX-NAV-VELNED (0x01 0x12): Velocity solution in NED frame</li>
<li>UBX-NAV-HPPOSECEF (0x01 0x13): High precision position solution in ECEF</li>
<li>UBX-NAV-HPPOSLLH (0x01 0x14): High precision geodetic position solution</li>
<li>UBX-NAV-PVAT (0x01 0x17): Navigation position velocity attitude time solution (<b>only with ADR or UDR products</b>)</li>
<li>UBX-NAV-CLOCK (0x01 0x22): Clock solution</li>
<li>UBX-NAV-SVIN (0x01 0x3B): Survey-in data (<b>only with High Precision GNSS products</b>)</li>
<li>UBX-NAV-RELPOSNED (0x01 0x3C): Relative positioning information in NED frame (<b>only with High Precision GNSS products</b>)</li>
<li>UBX-NAV-AOPSTATUS (0x01 0x60): AssistNow Autonomous status</li>
<li>UBX-RXM-SFRBX (0x02 0x13): Broadcast navigation data subframe</li>
<li>UBX-RXM-RAWX (0x02 0x15): Multi-GNSS raw measurement data (<b>only with ADR or High Precision GNSS or Time Sync products</b>)</li>
<li>UBX-TIM-TM2 (0x0D 0x03): Time mark data</li>
<li>UBX-ESF-ALG (0x10 0x14): IMU alignment information (<b>only with ADR or UDR products</b>)</li>
<li>UBX-ESF-INS (0x10 0x15): Vehicle dynamics information (<b>only with ADR or UDR products</b>)</li>
<li>UBX-ESF-MEAS (0x10 0x02): External sensor fusion measurements (<b>only with ADR or UDR products</b>)</li>
<li>UBX-ESF-RAW (0x10 0x03): Raw sensor measurements (<b>only with ADR or UDR products</b>)</li>
<li>UBX-ESF-STATUS (0x10 0x10): External sensor fusion status (<b>only with ADR or UDR products</b>)</li>
<li>UBX-HNR-PVT (0x28 0x00): High rate output of PVT solution (<b>only with ADR or UDR products</b>)</li>
<li>UBX-HNR-ATT (0x28 0x01): Attitude solution (<b>only with ADR or UDR products</b>)</li>
<li>UBX-HNR-INS (0x28 0x02): Vehicle dynamics information (<b>only with ADR or UDR products</b>)</li>
</ul>
<p >Please see <a class="el" href="md_src__spark_fun_u_blox__g_n_s_s__arduino__library_main__adding__new__messages.html">Adding_New_Messages</a> for details on how to add "auto" support for new messages.</p>
<p >Notes:</p><ul>
<li>UBX-NAV-POSLLH is not supported as UBX-NAV-PVT contains the same information</li>
<li>UBX-NAV-TIMEUTC is not supported as UBX-NAV-PVT contains the same information</li>
</ul>
<h1><a class="anchor" id="autotoc_md57"></a>
Migrating your code to v2.0</h1>
<p >Migrating to v2.0 is easy. There are two small changes all users will need to make:</p>
<ul>
<li>The name of the library class has changed from <code>SFE_UBLOX_GPS</code> to <code><a class="el" href="class_s_f_e___u_b_l_o_x___g_n_s_s.html">SFE_UBLOX_GNSS</a></code> to reflect that the library supports all of the Global Navigation Satellite Systems:<ul>
<li>As a minimum, you need to change: <code>SFE_UBLOX_GPS myGPS;</code></li>
<li>to: <code><a class="el" href="class_s_f_e___u_b_l_o_x___g_n_s_s.html">SFE_UBLOX_GNSS</a> myGPS;</code></li>
<li>But we would encourage you to use <code><a class="el" href="class_s_f_e___u_b_l_o_x___g_n_s_s.html">SFE_UBLOX_GNSS</a> myGNSS;</code>. You will see that all of the library examples now use <code>myGNSS</code> instead of <code>myGPS</code>.</li>
</ul>
</li>
<li>The name of the library header and C++ files have changed too:<ul>
<li>Change: <code>#include &lt;SparkFun_Ublox_Arduino_Library.h&gt;</code></li>
<li>to: <code>#include &lt;<a class="el" href="_g_n_s_s-_z_o_e-_m8_b-_s_o_l_d_e_r_e_d_8h.html" title="Arduino library for GNSS ZOE M8B.">GNSS-ZOE-M8B-SOLDERED.h</a>&gt;</code></li>
</ul>
</li>
</ul>
<p >The biggest change in v2.0 is that data is now stored in a <em>struct</em> which matches the u-blox interface description for that message. For example:</p><ul>
<li>In v1, the NAV PVT (Position Velocity Time) latitude and longitude were stored in 'global' <em>int32_t</em> variables called <code>latitude</code> and <code>longitude</code><ul>
<li>In v2.0, the data is now stored in <b><a class="el" href="struct_u_b_x___n_a_v___p_v_t__t.html">UBX_NAV_PVT_t</a> *packetUBXNAVPVT</b></li>
<li><code>myGPS.latitude</code> becomes <code>myGNSS.packetUBXNAVPVT-&gt;data.lat</code></li>
<li><code>myGPS.longitude</code> becomes <code>myGNSS.packetUBXNAVPVT-&gt;data.lon</code></li>
<li>The helper functions <code>myGNSS.getLatitude()</code> and <code>myGNSS.getLongitude()</code> are still available and work in the same way.</li>
</ul>
</li>
<li>In v1, the ESF Sensor Fusion data for the Dead Reckoning modules was stored in 'global' variables <code>imuMeas</code>, <code>ubloxSen</code> and <code>vehAtt</code><ul>
<li>In v2.0, the data is now stored in:</li>
<li><b><a class="el" href="struct_u_b_x___e_s_f___a_l_g__t.html">UBX_ESF_ALG_t</a> *packetUBXESFALG</b> contains the IMU alignment information (roll, pitch and yaw)</li>
<li><b><a class="el" href="struct_u_b_x___e_s_f___i_n_s__t.html">UBX_ESF_INS_t</a> *packetUBXESFINS</b> contains the vehicle dynamics information (acceleration and angular rate)</li>
<li><b><a class="el" href="struct_u_b_x___e_s_f___m_e_a_s__t.html">UBX_ESF_MEAS_t</a> *packetUBXESFMEAS</b> contains the sensor fusion measurements</li>
<li><b><a class="el" href="struct_u_b_x___e_s_f___r_a_w__t.html">UBX_ESF_RAW_t</a> *packetUBXESFRAW</b> contains the raw sensor measurements</li>
<li><b><a class="el" href="struct_u_b_x___e_s_f___s_t_a_t_u_s__t.html">UBX_ESF_STATUS_t</a> *packetUBXESFSTATUS</b> contains the sensor fusion status</li>
<li>e.g. <code>myGPS.imuMeas.fusionMode</code> becomes <code>myGNSS.packetUBXESFSTATUS-&gt;data.fusionMode</code></li>
<li>The helper functions <code>getSensorFusionMeasurement</code>, <code>getRawSensorMeasurement</code> and <code>getSensorFusionStatus</code> can be used to extract the sensor data for an individual sensor</li>
<li>"auto" data can be marked as stale by calling (e.g.) <code>myGNSS.flushESFALG()</code></li>
<li>Please see the <a href="./examples/Dead_Reckoning/Example4_vehicleDynamics/Example4_vehicleDynamics.ino"><b>Dead_Reckoning/Example4_vehicleDynamics</b></a> example for more details</li>
</ul>
</li>
<li>In v1, the HNR (High Navigation Rate) data for the Dead Reckoning modules was stored in 'global' variables <code>hnrAtt</code>, <code>hnrVehDyn</code> and <code>hnrPVT</code><ul>
<li>In v2.0, e.g.:</li>
<li><code>myGPS.hnrAtt.roll</code> becomes <code>myGNSS.packetUBXHNRATT-&gt;data.roll</code></li>
<li><code>myGPS.hnrVehDyn.xAccel</code> becomes <code>myGNSS.packetUBXHNRINS-&gt;data.xAccel</code></li>
<li><code>myGPS.hnrPVT.lat</code> becomes <code>myGNSS.packetUBXHNRPVT-&gt;data.lat</code></li>
<li>"auto" data can be marked as stale by calling (e.g.) <code>myGNSS.flushHNRATT()</code></li>
<li>Please see the <a href="./examples/Dead_Reckoning/Example6_getAutoHNRData/Example6_getAutoHNRData.ino"><b>Dead_Reckoning/Example6_getAutoHNRData</b></a> example for more details</li>
</ul>
</li>
</ul>
<p >Other changes include:</p><ul>
<li>In v1, NAV_RELPOSNED relPosN, relPosE and relPosD were returned as (float)m. In v2.0 they are returned via <b>packetUBXNAVRELPOSNED-&gt;data.relPosN</b> (etc.) as (int32_t)cm.<ul>
<li>New helper functions (<code>getRelPosN</code>, <code>getRelPosE</code> and <code>getRelPosD</code>) provide backward-compatibility</li>
<li>Please see the <a href="./examples/ZED-F9P/Example5_RelativePositioningInformation/Example5_RelativePositioningInformation.ino"><b>ZED-F9P/Example5_RelativePositioningInformation</b></a> example for more details</li>
</ul>
</li>
<li>In v1, NAV_RELPOSNED accN, accE and accD were returned as (float)m. In v2.0 they are returned via <b>packetUBXNAVRELPOSNED-&gt;data.accN</b> (etc.) as (uint32_t)mm*0.1.<ul>
<li>New helper functions (<code>getRelPosAccN</code>, <code>getRelPosAccE</code> and <code>getRelPosAccD</code>) provide backward-compatibility</li>
<li>Please see the <a href="./examples/ZED-F9P/Example5_RelativePositioningInformation/Example5_RelativePositioningInformation.ino"><b>ZED-F9P/Example5_RelativePositioningInformation</b></a> example for more details</li>
</ul>
</li>
<li>getSurveyStatus now returns data via <b><a class="el" href="struct_u_b_x___n_a_v___s_v_i_n__t.html">UBX_NAV_SVIN_t</a> *packetUBXNAVSVIN</b><ul>
<li><code>myGPS.svin.active</code> becomes <code>myGNSS.packetUBXNAVSVIN-&gt;data.active</code></li>
<li><code>myGPS.svin.valid</code> becomes <code>myGNSS.packetUBXNAVSVIN-&gt;data.valid</code></li>
<li><code>myGPS.svin.observationTime</code> becomes <code>myGNSS.packetUBXNAVSVIN-&gt;data.dur</code> and is now uint32_t (not uint16_t)</li>
<li><code>myGPS.svin.MeanAccuracy</code> becomes <code>myGNSS.packetUBXNAVSVIN-&gt;data.meanAcc</code> and is now uint32_t * 0.1mm (not float * m)</li>
<li>New helper functions (<code>getSurveyInActive</code>, <code>getSurveyInValid</code>, <code>getSurveyInObservationTime</code> and <code>getSurveyInMeanAccuracy</code>) provide backward-compatibility</li>
<li>Please see the <a href="./examples/ZED-F9P/Example3_StartRTCMBase/Example3_StartRTCMBase.ino"><b>ZED-F9P/Example3_StartRTCMBase</b></a> example for more details </li>
</ul>
</li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath">
    <!-- id is needed for treeview function! -->
    <ul>
        <li class="footer">
            Generated on Mon Feb 28 2022 10:43:29 for GNSS ZOE M8B Arduino Library by <a href="http://www.doxygen.org/index.html">
                <img class="footer" src="doxygen.png" alt="doxygen"
                    onerror="this.onerror=null;this.src='doxygen.svg';" /></a> 1.9.3.
            Dark theme by <a href="http://majerle.eu" target="_new">Tilen Majerle</a>. All rights reserved.
            Copyright: <a href="https://www.soldered.com">Soldered</a>
        </li>
    </ul>
</div>
<script src="custom.js"></script>
</body>
</html>
